# üîç An√°lise T√©cnica de Performance - Gincana Escolar

**Data:** 2024  
**Status:** Cr√≠tico - Identificados m√∫ltiplos gargalos de performance

---

## üìä Resumo Executivo

A an√°lise identificou **7 problemas cr√≠ticos** e **5 problemas moderados** que est√£o degradando significativamente a performance do sistema. Os principais gargalos est√£o relacionados a:

1. **N+1 Query Problem** no frontend (CR√çTICO)
2. **Consultas ineficientes** no backend (CR√çTICO)
3. **Falta de cache** (CR√çTICO)
4. **Consultas redundantes** (MODERADO)
5. **Falta de pagina√ß√£o** (MODERADO)

---

## üî¥ PROBLEMAS CR√çTICOS

### 1. N+1 Query Problem no Frontend - Ranking

**Localiza√ß√£o:** 
- `frontend/src/components/ModalRankingGincana.jsx` (linhas 37-79)
- `frontend/src/components/RankingInlineGincana.jsx` (linhas 45-87)
- `frontend/src/pages/aluno/RankingAluno.jsx` (linhas 126-162)

**Problema:**
```javascript
// ‚ùå PROBLEMA: Para cada equipe, faz 2 chamadas HTTP
const rows = await Promise.all(
    equipesDaGincana.map(async (e) => {
        // Chamada 1: membros/contagem
        const { data: contagem } = await api.get(`/equipes/${id}/membros/contagem`);
        
        // Chamada 2: pontua√ß√£o
        const { data: pont } = await api.get(`/equipes/${id}/pontuacao/gincana/${ativa.id}`);
    })
);
```

**Impacto:**
- Se existem **10 equipes**, s√£o feitas **20 requisi√ß√µes HTTP** (2 por equipe)
- Cada requisi√ß√£o tem lat√™ncia de rede (~50-200ms)
- **Tempo total:** ~1-4 segundos apenas em lat√™ncia de rede
- Al√©m disso, cada requisi√ß√£o dispara m√∫ltiplas consultas ao Firestore

**Solu√ß√£o:**
O backend j√° possui o endpoint `/gincanas/:id/ranking` que calcula o ranking completo de uma vez. O frontend deveria usar este endpoint ao inv√©s de fazer m√∫ltiplas chamadas.

**C√≥digo atual (backend j√° existe):**
```javascript
// backend/src/routes/gincanas.js linha 200-212
router.get("/:id/ranking", async (req, res) => {
    const ranking = await calcularRankingGincana(id);
    res.json({ gincanaId: id, ranking });
});
```

**Ganho estimado:** Redu√ß√£o de **80-90%** no tempo de carregamento do ranking.

---

### 2. Consulta Ineficiente: pontuacaoAcumuladaEquipeNaGincana

**Localiza√ß√£o:** `backend/src/services/pontuacao.js` (linhas 202-260)

**Problema:**
```javascript
// ‚ùå PROBLEMA: Busca TODAS as atividades da gincana primeiro
const atvsSnap = await db
    .collection("atividades")
    .where("gincanaId", "==", gincanaId.trim())
    .get();

const atividadeIds = atvsSnap.docs.map((d) => d.id);

// Depois busca TODAS as pontua√ß√µes da equipe
const pontSnap = await db
    .collection("pontuacoes")
    .where("equipeId", "==", equipeId.trim())
    .get();

// E filtra em mem√≥ria (ineficiente!)
const itens = pontSnap.docs
    .map((doc) => ({ id: doc.id, ...doc.data() }))
    .filter((p) => setAtividades.has(p.atividadeId));
```

**Impacto:**
- Busca **todas** as atividades da gincana mesmo quando n√£o precisa
- Busca **todas** as pontua√ß√µes da equipe (de todas as gincanas)
- Filtra em mem√≥ria ao inv√©s de usar √≠ndices do banco
- Quando chamado N vezes (uma por equipe), multiplica o problema

**Solu√ß√£o:**
Usar a estrutura de dados existente: `equipes.pontuacoesIds` j√° cont√©m os IDs das pontua√ß√µes da equipe. Basta buscar apenas essas pontua√ß√µes e filtrar por `atividadeId` que pertence √† gincana.

**Ganho estimado:** Redu√ß√£o de **60-70%** no tempo de consulta.

---

### 3. Consulta Redundante: listarEquipes() sem filtro

**Localiza√ß√£o:**
- `backend/src/services/equipeService.js` (linha 37-44)
- `frontend/src/components/ModalRankingGincana.jsx` (linha 31)

**Problema:**
```javascript
// ‚ùå Backend: busca TODAS as equipes
async function listarEquipes() {
    const qs = await db.collection(COLL).get(); // SEM FILTRO!
    return qs.docs.map(...);
}

// ‚ùå Frontend: filtra no cliente ap√≥s receber tudo
const todas = await listarEquipes();
const equipesDaGincana = (todas || []).filter(
    (e) => (e.gincanaId || e?.gincana?.id) === ativa.id
);
```

**Impacto:**
- Transfere dados desnecess√°rios pela rede
- Processa dados desnecess√°rios no frontend
- O backend j√° tem `listarEquipesPorGincana()` mas n√£o √© usado

**Solu√ß√£o:**
Usar `listarEquipesPorGincana({ gincanaId })` que j√° existe no backend.

**Ganho estimado:** Redu√ß√£o de **50-80%** no tamanho da resposta (dependendo do n√∫mero de equipes).

---

### 4. N+1 Query Problem: rankingDaAtividade

**Localiza√ß√£o:** `backend/src/services/pontuacao.js` (linhas 157-174)

**Problema:**
```javascript
// ‚ùå PROBLEMA: Para cada equipe √∫nica, faz uma consulta individual
if (incluirEquipe && ordenados.length > 0) {
    const uniqueEquipeIds = [...new Set(...)];
    await Promise.all(
        uniqueEquipeIds.map(async (id) => {
            const doc = await db.collection("equipes").doc(id).get(); // Consulta individual!
        })
    );
}
```

**Impacto:**
- Se h√° 10 equipes diferentes, faz 10 consultas individuais
- Poderia usar `where("__name__", "in", ids)` com batch de 10

**Solu√ß√£o:**
Usar consulta em batch com `where("__name__", "in", ids)` similar ao que j√° √© feito em `fetchPontuacoesByIds()`.

**Ganho estimado:** Redu√ß√£o de **70-80%** no tempo de consulta.

---

### 5. Falta de Cache

**Problema:**
Nenhum sistema de cache est√° implementado. Dados que mudam pouco s√£o recalculados/reconsultados a cada requisi√ß√£o:

- Rankings de gincana
- Lista de equipes
- Dados de gincana ativa
- Pontua√ß√µes acumuladas

**Impacto:**
- Mesmo dados s√£o consultados repetidamente
- Ranking √© recalculado a cada visualiza√ß√£o
- Consultas desnecess√°rias ao Firestore

**Solu√ß√£o:**
Implementar cache em mem√≥ria (Redis ou Node.js Map) com TTL:
- Rankings: cache de 30-60 segundos
- Lista de equipes: cache de 5 minutos
- Dados de gincana: cache de 1 minuto

**Ganho estimado:** Redu√ß√£o de **90-95%** nas consultas ao banco para dados cacheados.

---

### 6. Ordena√ß√£o em Mem√≥ria ao Inv√©s de √çndices

**Localiza√ß√£o:** `backend/src/services/atividadesService.js` (linhas 101-105)

**Problema:**
```javascript
// ‚ùå Busca sem orderBy e ordena em mem√≥ria
const snap = await query.get();
atividades.sort((a, b) => {
    const ta = new Date(a?.inicio || 0).getTime();
    const tb = new Date(b?.inicio || 0).getTime();
    return ta - tb;
});
```

**Impacto:**
- N√£o aproveita √≠ndices do Firestore
- Carrega todos os documentos antes de ordenar
- Processa dados desnecess√°rios

**Solu√ß√£o:**
Usar `orderBy("inicio", "asc")` do Firestore ap√≥s criar o √≠ndice apropriado.

**Ganho estimado:** Redu√ß√£o de **40-60%** no tempo de consulta.

---

### 7. Consulta Duplicada: listarEquipes() em M√∫ltiplos Componentes

**Localiza√ß√£o:**
- `RankingAluno.jsx` carrega ranking
- `RankingInlineGincana.jsx` tamb√©m carrega ranking
- Ambos chamam `listarEquipes()` independentemente

**Problema:**
Quando `RankingAluno` renderiza `RankingInlineGincana` como filho, ambos fazem as mesmas consultas.

**Impacto:**
- Requisi√ß√µes duplicadas
- Processamento duplicado
- Dados transferidos duas vezes

**Solu√ß√£o:**
Compartilhar dados via Context API ou props, ou usar o endpoint de ranking consolidado.

**Ganho estimado:** Redu√ß√£o de **50%** nas requisi√ß√µes redundantes.

---

## üü° PROBLEMAS MODERADOS

### 8. Falta de Pagina√ß√£o

**Localiza√ß√£o:**
- `backend/src/services/usuariosService.js` (linha 36-58)
- `backend/src/services/equipeService.js` (linha 37-44)

**Problema:**
Listagens sem limite ou pagina√ß√£o adequada podem retornar milhares de documentos.

**Impacto:**
- Tempo de resposta cresce linearmente com o volume
- Consumo excessivo de mem√≥ria
- Transfer√™ncia de dados desnecess√°rios

**Solu√ß√£o:**
Implementar pagina√ß√£o com cursor-based pagination (Firestore) ou limit/offset.

---

### 9. Busca de Todas as Equipes para Filtro no Frontend

**Localiza√ß√£o:** M√∫ltiplos componentes do frontend

**Problema:**
Frontend busca todas as equipes e filtra no cliente, quando deveria buscar apenas as necess√°rias.

**Solu√ß√£o:**
Usar endpoints filtrados do backend ou implementar query parameters no frontend.

---

### 10. M√∫ltiplas Consultas ao Firebase em Sequ√™ncia

**Localiza√ß√£o:** `backend/src/services/pontuacao.js`

**Problema:**
Algumas opera√ß√µes fazem m√∫ltiplas consultas sequenciais que poderiam ser paralelas ou consolidadas.

**Solu√ß√£o:**
Usar `Promise.all()` para consultas paralelas quando poss√≠vel.

---

### 11. Falta de Compress√£o HTTP

**Problema:**
Respostas JSON grandes n√£o est√£o sendo comprimidas (gzip/brotli).

**Impacto:**
Transfer√™ncia de dados maior que o necess√°rio.

**Solu√ß√£o:**
Habilitar compress√£o no Express: `app.use(compression())`.

---

### 12. Re-renderiza√ß√µes Desnecess√°rias no Frontend

**Problema:**
Alguns componentes podem estar re-renderizando sem necessidade devido a depend√™ncias de `useEffect` ou falta de memoiza√ß√£o.

**Solu√ß√£o:**
Revisar depend√™ncias de hooks e usar `React.memo`, `useMemo`, `useCallback` adequadamente.

---

## üìà PLANO DE A√á√ÉO PRIORIT√ÅRIO

### Fase 1 - Impacto Imediato (1-2 dias)

1. **‚úÖ Refatorar componentes de ranking no frontend**
   - Usar `/gincanas/:id/ranking` ao inv√©s de m√∫ltiplas chamadas
   - Ganho esperado: **80-90%** de redu√ß√£o no tempo

2. **‚úÖ Otimizar pontuacaoAcumuladaEquipeNaGincana**
   - Usar `pontuacoesIds` ao inv√©s de buscar todas as pontua√ß√µes
   - Ganho esperado: **60-70%** de redu√ß√£o

3. **‚úÖ Usar listarEquipesPorGincana no frontend**
   - Evitar buscar todas as equipes
   - Ganho esperado: **50-80%** de redu√ß√£o no payload

### Fase 2 - Cache (2-3 dias)

4. **‚úÖ Implementar cache em mem√≥ria**
   - Cache de rankings (30-60s)
   - Cache de listas est√°ticas (5min)
   - Ganho esperado: **90-95%** nas consultas cacheadas

### Fase 3 - Otimiza√ß√µes de Consulta (3-5 dias)

5. **‚úÖ Otimizar rankingDaAtividade**
   - Usar batch queries para equipes
   - Ganho esperado: **70-80%**

6. **‚úÖ Implementar pagina√ß√£o**
   - Usu√°rios, equipes, atividades
   - Ganho esperado: Escalabilidade melhorada

7. **‚úÖ Usar √≠ndices do Firestore**
   - orderBy em consultas
   - Criar √≠ndices compostos quando necess√°rio
   - Ganho esperado: **40-60%**

---

## üß™ COMO MEDIR OS GANHOS

### M√©tricas a Coletar

1. **Tempo de Resposta (Lat√™ncia)**
   ```javascript
   // Adicionar middleware de logging
   app.use((req, res, next) => {
       const start = Date.now();
       res.on('finish', () => {
           console.log(`${req.method} ${req.path} - ${Date.now() - start}ms`);
       });
       next();
   });
   ```

2. **N√∫mero de Consultas ao Firestore**
   ```javascript
   // Instrumentar Firebase Admin SDK
   db.collection('test').get().then(() => {
       console.log('Firestore query executed');
   });
   ```

3. **Tamanho das Respostas HTTP**
   - Usar DevTools Network tab
   - Medir antes/depois das otimiza√ß√µes

4. **Tempo de Carregamento no Frontend**
   ```javascript
   // Performance API
   const perfData = performance.getEntriesByType('navigation')[0];
   console.log('Load time:', perfData.loadEventEnd - perfData.fetchStart);
   ```

### Ferramentas Recomendadas

- **Backend:**
  - `clinic.js` ou `0x` para profiling
  - `@google-cloud/trace-agent` para tracing
  - Logs estruturados com timestamps

- **Frontend:**
  - Chrome DevTools Performance tab
  - React DevTools Profiler
  - Network tab para an√°lise de requisi√ß√µes

- **Firebase:**
  - Firebase Console > Usage tab
  - Monitorar reads/writes

### Benchmarks Esperados

**Antes das otimiza√ß√µes:**
- Ranking completo: **3-8 segundos**
- Carregamento de p√°gina: **2-5 segundos**
- Consultas ao Firestore: **50-100+ por p√°gina**

**Ap√≥s Fase 1:**
- Ranking completo: **0.5-1.5 segundos** (redu√ß√£o de 75-85%)
- Carregamento de p√°gina: **0.8-2 segundos** (redu√ß√£o de 60-70%)
- Consultas ao Firestore: **5-15 por p√°gina** (redu√ß√£o de 80-90%)

**Ap√≥s Fase 2 (com cache):**
- Ranking completo: **0.1-0.3 segundos** (cache hit)
- Carregamento de p√°gina: **0.3-0.8 segundos**
- Consultas ao Firestore: **1-3 por p√°gina** (cache miss)

---

## üéØ CONCLUS√ÉO

Os principais gargalos s√£o:

1. **N+1 Query Problem no frontend** - Maior impacto imediato
2. **Consultas ineficientes no backend** - Multiplicam o problema
3. **Falta de cache** - Afeta todos os endpoints

**Priorizar as otimiza√ß√µes da Fase 1** trar√° ganhos imediatos e significativos com esfor√ßo relativamente baixo. A implementa√ß√£o de cache (Fase 2) ter√° o maior impacto de longo prazo.

---

## üìù NOTAS T√âCNICAS

### Firestore Limits
- M√°ximo de 10 IDs em query `IN`
- Consultas em batch s√£o necess√°rias para mais de 10 itens
- √çndices compostos devem ser criados para queries complexas

### Recomenda√ß√µes de Arquitetura
- Considerar GraphQL para reduzir over-fetching
- Implementar DataLoader pattern para batch queries
- Usar Redis para cache distribu√≠do em produ√ß√£o
- Implementar rate limiting para proteger contra abuso

---

**Documento gerado em:** 2024  
**√öltima atualiza√ß√£o:** 2024

